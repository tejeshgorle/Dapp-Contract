// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/Pausable.sol";

contract MegaRegistry is ReentrancyGuard, Ownable, Pausable {
    constructor() Ownable(msg.sender) {}

    // ERRORS
    error UserAlreadyExists();
    error UserNotRegistered();
    error ContactAlreadyAdded();
    error ContractNotFound();
    error NotAuthorized();
    error AlreadySigned();
    error AlreadyDenied();
    error PropertyNotFound();
    error TransferNotFound();
    error InsufficientFunds();
    error TransferAlreadyProcessed();
    error ContractAlreadyFinalized();

    // STRUCTS & STORAGE

    // UserLib
    struct User {
        bytes32 username;
        bytes32 panHash;
        address wallet;
        bool exists;
    }

    struct UserState {
        mapping(address => User) users;
        mapping(bytes32 => address) usernameToWallet;
        address[] allUsers;
    }

    UserState private userState;

    //ContactLib
    struct ContactState {
        mapping(address => address[]) contacts;
    }

    ContactState private contactState;

    // ContractSignLib
    enum ContractStatus {
        PENDING,
        COMPLETED,
        CANCELED
    }

    struct MultiPartyContract {
        uint256 id;
        string cid; // UPDATED
        address creator;
        address[] signers;
        mapping(address => bool) signed;
        mapping(address => bool) denied;
        ContractStatus status;
        uint256 signedCount;
    }

    struct ContractState {
        uint256 nextId;
        mapping(uint256 => MultiPartyContract) contracts;
        mapping(address => uint256[]) createdByUser;
        mapping(address => uint256[]) signedByUser;
        mapping(address => uint256[]) contractsWhereParty;
    }

    ContractState private contractState;

    // Property & Escrow

    struct PropertyOwnershipRecord {
        address previousOwner;
        address newOwner;
        uint256 transferDate;
    }

    struct PropertyTransfer {
        uint256 propertyId;
        address buyer;
        uint256 price;
        uint256 initiatedAt;
        bool accepted;
        bool processed;
    }

    enum SaleStatus {
        INITIATED,
        ACCEPTED,
        PAID,
        DENIED_BY_BUYER,
        CANCELLED,
        COMPLETED
    }

    struct Sale {
        uint256 propertyId;
        address seller;
        address buyer;
        uint256 price;
        SaleStatus status;
        uint256 initiatedAt;
    }

    struct Property {
        uint256 id;
        string cid; // UPDATED
        address owner;
        uint256 registeredAt;
        uint256 dateOfLastTransfer;
        uint256 dateOfOwnershipChange;
        bool exists;
    }

    struct PropertyState {
        uint256 nextId;
        mapping(uint256 => Property) properties;
        mapping(address => uint256[]) ownerProperties;
        mapping(uint256 => PropertyTransfer) transfers;
        mapping(uint256 => PropertyOwnershipRecord[]) ownershipHistory;
        mapping(uint256 => Sale) sales;
    }

    PropertyState private propertyState;

    mapping(address => uint256[]) private incomingSales;
    mapping(address => uint256[]) private outgoingSales;

    // EVENTS
    event UserRegistered(address wallet, bytes32 username);
    event ContactAdded(address user, address contact);

    event ContractCreated(uint256 id, address creator, string cid); // UPDATED
    event ContractSigned(uint256 id, address signer);
    event ContractDenied(uint256 id, address signer);
    event ContractCanceled(uint256 id, address caller);
    event ContractCompleted(uint256 id);

    event PropertyRegistered(uint256 propertyId, address owner, string cid); // UPDATED

    event PropertySaleProposed(
        uint256 indexed propertyId,
        address indexed seller,
        uint256 price,
        uint256 timestamp
    );
    event PropertySalePaid(
        uint256 indexed propertyId,
        address indexed buyer,
        uint256 price
    );
    event PropertySaleDeclined(
        uint256 indexed propertyId,
        address indexed buyer
    );
    event PropertyTransferred(
        uint256 indexed propertyId,
        address indexed oldOwner,
        address indexed newOwner,
        uint256 timestamp,
        uint256 price
    );
    event DirectOwnershipTransfer(
        uint256 indexed propertyId,
        address indexed oldOwner,
        address indexed newOwner,
        uint256 timestamp
    );

    // USER FUNCTIONS
    function registerUser(
        bytes32 username,
        bytes32 panHash
    ) external whenNotPaused {
        if (userState.users[msg.sender].exists) revert UserAlreadyExists();
        if (userState.usernameToWallet[username] != address(0))
            revert UserAlreadyExists();

        userState.users[msg.sender] = User(username, panHash, msg.sender, true);
        userState.usernameToWallet[username] = msg.sender;
        userState.allUsers.push(msg.sender);

        emit UserRegistered(msg.sender, username);
    }

    function isUserRegistered(address wallet) external view returns (bool) {
        return userState.users[wallet].exists;
    }

    function fetchUserDetail(
        address wallet
    ) external view returns (User memory) {
        if (!userState.users[wallet].exists) revert UserNotRegistered();
        return userState.users[wallet];
    }

    function fetchAllUsers() external view returns (User[] memory) {
        uint256 len = userState.allUsers.length;
        User[] memory list = new User[](len);

        for (uint256 i = 0; i < len; i++)
            list[i] = userState.users[userState.allUsers[i]];

        return list;
    }

    // CONTACT FUNCTIONS
    function addToMyContacts(address contact) external whenNotPaused {
        address[] storage myContacts = contactState.contacts[msg.sender];

        for (uint256 i = 0; i < myContacts.length; i++)
            if (myContacts[i] == contact) revert ContactAlreadyAdded();

        myContacts.push(contact);
        emit ContactAdded(msg.sender, contact);
    }

    function fetchMyContacts(
        address wallet
    ) external view returns (User[] memory) {
        address[] storage wallets = contactState.contacts[wallet];
        User[] memory list = new User[](wallets.length);

        for (uint256 i = 0; i < wallets.length; i++)
            list[i] = userState.users[wallets[i]];

        return list;
    }

    // MULTI-PARTY CONTRACTS
    function createContract(
        string calldata cid,
        address[] calldata signers
    ) external whenNotPaused {
        uint256 id = contractState.nextId++;

        MultiPartyContract storage c = contractState.contracts[id];
        c.id = id;
        c.cid = cid; // UPDATED
        c.creator = msg.sender;
        c.signers = signers;
        c.status = ContractStatus.PENDING;
        c.signedCount = 0;

        contractState.createdByUser[msg.sender].push(id);

        for (uint256 i = 0; i < signers.length; i++) {
            contractState.contractsWhereParty[signers[i]].push(id);
        }

        emit ContractCreated(id, msg.sender, cid);
    }

    function signContract(uint256 contractId) external whenNotPaused {
        MultiPartyContract storage c = contractState.contracts[contractId];
        if (c.creator == address(0)) revert ContractNotFound();
        if (c.status != ContractStatus.PENDING)
            revert ContractAlreadyFinalized();

        bool isSigner = false;
        for (uint256 i = 0; i < c.signers.length; i++) {
            if (c.signers[i] == msg.sender) {
                isSigner = true;
                break;
            }
        }

        if (!isSigner) revert NotAuthorized();
        if (c.signed[msg.sender]) revert AlreadySigned();
        if (c.denied[msg.sender]) revert AlreadyDenied();

        c.signed[msg.sender] = true;
        c.signedCount++;

        contractState.signedByUser[msg.sender].push(contractId);

        emit ContractSigned(contractId, msg.sender);

        if (c.signedCount == c.signers.length) {
            c.status = ContractStatus.COMPLETED;
            emit ContractCompleted(contractId);
        }
    }

    function denyContract(uint256 contractId) external whenNotPaused {
        MultiPartyContract storage c = contractState.contracts[contractId];
        if (c.creator == address(0)) revert ContractNotFound();
        if (c.status != ContractStatus.PENDING)
            revert ContractAlreadyFinalized();

        bool isSigner = false;
        for (uint256 i = 0; i < c.signers.length; i++) {
            if (c.signers[i] == msg.sender) {
                isSigner = true;
                break;
            }
        }

        if (!isSigner) revert NotAuthorized();
        if (c.signed[msg.sender]) revert AlreadySigned();
        if (c.denied[msg.sender]) revert AlreadyDenied();

        c.denied[msg.sender] = true;

        contractState.signedByUser[msg.sender].push(contractId);

        emit ContractDenied(contractId, msg.sender);

        c.status = ContractStatus.CANCELED;
        emit ContractCanceled(contractId, msg.sender);
    }

    function cancelContract(uint256 contractId) external whenNotPaused {
        MultiPartyContract storage c = contractState.contracts[contractId];
        if (c.creator != msg.sender) revert NotAuthorized();
        if (c.status != ContractStatus.PENDING)
            revert ContractAlreadyFinalized();

        c.status = ContractStatus.CANCELED;
        emit ContractCanceled(contractId, msg.sender);
    }

    function retrieveContractInfo(
        uint256 contractId
    )
        external
        view
        returns (
            uint256 id,
            string memory cid,
            address creator,
            address[] memory signers,
            ContractStatus status,
            uint256 signedCount
        )
    {
        MultiPartyContract storage c = contractState.contracts[contractId];
        if (c.creator == address(0)) revert ContractNotFound();

        return (c.id, c.cid, c.creator, c.signers, c.status, c.signedCount);
    }

    function hasUserSigned(
        uint256 contractId,
        address user
    ) external view returns (bool) {
        MultiPartyContract storage c = contractState.contracts[contractId];
        if (c.creator == address(0)) revert ContractNotFound();
        return c.signed[user];
    }

    function hasUserDenied(
        uint256 contractId,
        address user
    ) external view returns (bool) {
        MultiPartyContract storage c = contractState.contracts[contractId];
        if (c.creator == address(0)) revert ContractNotFound();
        return c.denied[user];
    }

    function getContractsWhereUserIsParty(
        address user
    ) external view returns (uint256[] memory) {
        return contractState.contractsWhereParty[user];
    }

    // PROPERTY SYSTEM
    function registerProperty(string calldata cid) external whenNotPaused {
        uint256 id = propertyState.nextId++;

        propertyState.properties[id] = Property({
            id: id,
            cid: cid,
            owner: msg.sender,
            registeredAt: block.timestamp,
            dateOfLastTransfer: 0,
            dateOfOwnershipChange: block.timestamp,
            exists: true
        });

        propertyState.ownerProperties[msg.sender].push(id);

        propertyState.ownershipHistory[id].push(
            PropertyOwnershipRecord({
                previousOwner: address(0),
                newOwner: msg.sender,
                transferDate: block.timestamp
            })
        );

        emit PropertyRegistered(id, msg.sender, cid);
    }

    function retrieveUserProperties(
        address owner
    ) external view returns (Property[] memory) {
        uint256[] storage ids = propertyState.ownerProperties[owner];
        Property[] memory list = new Property[](ids.length);

        for (uint256 i = 0; i < ids.length; i++)
            list[i] = propertyState.properties[ids[i]];

        return list;
    }

    function retrievePropertyInfo(
        uint256 propertyId
    )
        external
        view
        returns (
            uint256 id,
            string memory cid,
            address owner,
            uint256 registeredAt,
            uint256 dateOfLastTransfer,
            uint256 dateOfOwnershipChange
        )
    {
        Property storage p = propertyState.properties[propertyId];
        if (!p.exists) revert PropertyNotFound();

        return (
            p.id,
            p.cid,
            p.owner,
            p.registeredAt,
            p.dateOfLastTransfer,
            p.dateOfOwnershipChange
        );
    }

    function getPreviousOwner(
        uint256 propertyId
    ) external view returns (address previousOwner, uint256 transferDate) {
        if (!propertyState.properties[propertyId].exists)
            revert PropertyNotFound();

        PropertyOwnershipRecord[] storage history = propertyState
            .ownershipHistory[propertyId];
        uint256 len = history.length;

        if (len == 0) return (address(0), 0);

        PropertyOwnershipRecord storage r = history[len - 1];
        return (r.previousOwner, r.transferDate);
    }

    function getOwnershipHistory(
        uint256 propertyId
    ) external view returns (PropertyOwnershipRecord[] memory) {
        if (!propertyState.properties[propertyId].exists)
            revert PropertyNotFound();

        return propertyState.ownershipHistory[propertyId];
    }

    function getPropertySaleDetails(
        uint256 propertyId
    ) external view returns (Sale memory) {
        return propertyState.sales[propertyId];
    }

    function getAgreementStatus(
        uint256 propertyId
    ) external view returns (SaleStatus) {
        return propertyState.sales[propertyId].status;
    }

    // DIRECT OWNERSHIP TRANSFER
    function transferOwnership(
        uint256 propertyId,
        address newOwner
    ) external whenNotPaused {
        Property storage p = propertyState.properties[propertyId];
        if (!p.exists) revert PropertyNotFound();
        if (p.owner != msg.sender) revert NotAuthorized();
        if (newOwner == address(0)) revert NotAuthorized();

        address previousOwner = p.owner;

        p.owner = newOwner;
        p.dateOfLastTransfer = block.timestamp;
        p.dateOfOwnershipChange = block.timestamp;

        _removePropertyFromOwner(previousOwner, propertyId);
        propertyState.ownerProperties[newOwner].push(propertyId);

        propertyState.ownershipHistory[propertyId].push(
            PropertyOwnershipRecord({
                previousOwner: previousOwner,
                newOwner: newOwner,
                transferDate: block.timestamp
            })
        );

        emit DirectOwnershipTransfer(
            propertyId,
            previousOwner,
            newOwner,
            block.timestamp
        );
    }

    function _removePropertyFromOwner(
        address owner,
        uint256 propertyId
    ) internal {
        uint256[] storage list = propertyState.ownerProperties[owner];
        uint256 len = list.length;

        for (uint256 i = 0; i < len; i++) {
            if (list[i] == propertyId) {
                list[i] = list[len - 1];
                list.pop();
                return;
            }
        }
    }

    // SALE & ESCROW FLOW
    function proposePropertySale(
        uint256 propertyId,
        uint256 price,
        address buyer
    ) external whenNotPaused returns (uint256) {
        Property storage p = propertyState.properties[propertyId];
        if (!p.exists) revert PropertyNotFound();
        if (p.owner != msg.sender) revert NotAuthorized();
        if (price == 0) revert InsufficientFunds();
        if (buyer == address(0)) revert NotAuthorized();

        propertyState.sales[propertyId] = Sale({
            propertyId: propertyId,
            seller: msg.sender,
            buyer: buyer,
            price: price,
            status: SaleStatus.INITIATED,
            initiatedAt: block.timestamp
        });

        outgoingSales[msg.sender].push(propertyId);
        incomingSales[buyer].push(propertyId);

        emit PropertySaleProposed(
            propertyId,
            msg.sender,
            price,
            block.timestamp
        );
        return propertyId;
    }

    function getIncomingSaleRequests(
        address buyer
    ) external view returns (uint256[] memory) {
        return incomingSales[buyer];
    }

    function getOutgoingSaleRequests(
        address seller
    ) external view returns (uint256[] memory) {
        return outgoingSales[seller];
    }

    function buyerAcceptSale(uint256 propertyId) external whenNotPaused {
        Sale storage s = propertyState.sales[propertyId];

        if (s.status != SaleStatus.INITIATED) revert TransferNotFound();
        if (s.buyer != msg.sender) revert NotAuthorized();

        s.status = SaleStatus.ACCEPTED;
    }

    function buyerDeclineSale(uint256 propertyId) external whenNotPaused {
        Sale storage s = propertyState.sales[propertyId];

        if (s.status != SaleStatus.INITIATED && s.status != SaleStatus.ACCEPTED)
            revert TransferNotFound();
        if (s.buyer != msg.sender) revert NotAuthorized();

        s.status = SaleStatus.DENIED_BY_BUYER;
        emit PropertySaleDeclined(propertyId, msg.sender);
    }

    function buyerPay(
        uint256 propertyId
    ) external payable whenNotPaused nonReentrant {
        Sale storage s = propertyState.sales[propertyId];

        if (s.status != SaleStatus.ACCEPTED) revert TransferNotFound();
        if (s.buyer != msg.sender) revert NotAuthorized();
        if (msg.value != s.price) revert InsufficientFunds();

        s.status = SaleStatus.PAID;
        emit PropertySalePaid(propertyId, msg.sender, msg.value);
    }

    function sellerCancelSale(uint256 propertyId) external whenNotPaused {
        Sale storage s = propertyState.sales[propertyId];
        if (s.seller != msg.sender) revert NotAuthorized();
        if (s.status != SaleStatus.INITIATED && s.status != SaleStatus.PAID)
            revert TransferNotFound();

        s.status = SaleStatus.CANCELLED;

        emit PropertySaleDeclined(propertyId, msg.sender);
    }

    function finalizeSale(
        uint256 propertyId
    ) external whenNotPaused nonReentrant {
        Sale storage s = propertyState.sales[propertyId];
        if (s.seller == address(0)) revert TransferNotFound();
        if (s.seller != msg.sender) revert NotAuthorized();
        if (s.status != SaleStatus.PAID) revert TransferNotFound();

        Property storage p = propertyState.properties[propertyId];
        if (!p.exists) revert PropertyNotFound();

        address seller = s.seller;
        address buyer = s.buyer;
        uint256 amount = s.price;
        address previousOwner = p.owner;

        p.owner = buyer;
        p.dateOfLastTransfer = block.timestamp;
        p.dateOfOwnershipChange = block.timestamp;

        _removePropertyFromOwner(previousOwner, propertyId);
        propertyState.ownerProperties[buyer].push(propertyId);

        propertyState.ownershipHistory[propertyId].push(
            PropertyOwnershipRecord({
                previousOwner: previousOwner,
                newOwner: buyer,
                transferDate: block.timestamp
            })
        );

        s.status = SaleStatus.COMPLETED;

        (bool sent, ) = seller.call{value: amount}("");
        require(sent, "Payment failed");

        emit PropertyTransferred(
            propertyId,
            previousOwner,
            buyer,
            block.timestamp,
            amount
        );
    }

    // ADMIN
    function pause() external onlyOwner {
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}
